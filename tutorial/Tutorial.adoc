= Tutorial

== cmake Basics

This section is not meant to be a full tutorial on cmake, but hopefully is enough to get you started.

=== Introduction to cmake

CMake is a two step build process.  The developer writes a CMakeLists.txt file in the cmake language.  Using your CMakeLists.txt file, cmake creates a makefile (or similar) defining how to create a set of output files from a set of input files.  It also keeps track of what outputs need to be regenerated if changes are made to the inputs.

The makefile (or similar) is then used to generate the output files from the input files.

When using any build system like cmake, there are several key components:

* input files
* recipes
* recipe dependencies
* output files
* targets

A recipe is a set of instructions to convert a set of input files into a set of output files.

Input files to a recipe can either be input files, or outputs generated from other recipes.

A recipe dependency is a file that, if changed, implies that the recipe should be rerun.  For example, if you edit a verilog source file, you will need to rebuild a bit file that was generated from that verilog file.  The bit file depends on the verilog file.

This is different than a source dependency.  Only output files can have recipe dependencies because the recipe dependencies are what are used to generate a file.  A source file's source dependency is used by that source file, but is not used to produce that source file.

In cmake, any specified recipe dependency must be a file that already exists or that cmake has a recipe that describes that file as an output.

A target (sometimes called a phony target) is a named fake output that always needs to be rebuilt.  Using the command "make <target name>" produces all of the outputs that were specified as dependencies of the target (and all of the dependencies necessary to create that target).  The recipe dependencies of the target "ALL" are produced if the command "make" is used with no output or target specified.

=== Getting started

In the top level directory of your project, create a text file called CMakeLists.txt

The first two lines of your project should define the minimum version of cmake that can be used for your project and the project name.  All the versions of vivado I checked provide cmake version 3.3.

You can add comments by starting a line with the # symbol.

[source,cmake]
make_minimum_required(VERSION 3.3)
project(helloworld)

I recommend that you force the user to build out of tree (create a separate build folder to put all outputs in).  You can accomplish this by adding the lines

[source,cmake]
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)

Variables don't need to be declared before being assigned.  You can assign variables using the "set" function and access them by prepending the variable name by a dollar sign and surrounding it with braces (e.g. "${varname}")

[source,cmake]
set(mymessage "Hello World!")

You can output messages to the user when cmake is run by using the "message" function

[source,cmake]
message(STATUS ${mymessage})

Our CMakeLists.txt file now looks like this

[source,cmake]
cmake_minimum_required(VERSION 3.3)
project(helloworld)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)
set(mymessage "Hello World!")
message(STATUS ${mymessage})

To run cmake, create a build directory in your project adjacent to the CMakeLists.txt file, navigate to that build directory, and run "cmake .." from command line.  If all goes well, it will welcome you to the world of cmake.

=== File paths and includes

In cmake, filepaths should use forward slashes, not backslashes, even if you are on windows.

To be able to use the functions in viv-prj-gen, you need to get viv-prj-gen on your computer, and to use the "include" function on the path to the .cmake file with the functions you want in it.

I recommend using viv-prj-gen as a git submodule or a git subtree.

The start of your CMakeLists.txt might look like this
[source,cmake]
cmake_minimum_required(VERSION 3.3)
project(helloworld)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)
include(viv-prj-gen/vivgen_functions.cmake)
include(viv-prj-gen/cmake_utils/file_functions.cmake)

Included cmake files have their own scope for variables.  The parent variables are copied into the include cmake file's environment.  The included cmake file can explicitly set variables in the parent scope.  This is often used in functions to return by value.

=== Getting the Source Files

There are a number of ways of specifying filenames in cmake.  There are several goals when specifying filepaths in cmake.

Paths that you write should be relative (so that you can move from machine to machine or change the directory you store stuff in).

The paths that you use should be absolute (so that the user doesn't have to know from what directory you are referring to).

The following sections has several methods.  The appendix lists another one.

==== GLOB

The easiset way to get filepaths in cmake to use is file(GLOB varname path_to_file).  file glob sets the passed variable to a list of full paths of exisiting files that match the passed path.

Some cmake users recommend against using glob in cmake because it will silently fail to detect files added after running cmake.

If you had the following source tree

[source, verbatim]
.
├── build
├── CMakeLists.txt
├── hdl
│   ├── DFlipFlop.vhdl
│   └── GenericDFlipFlop.vhdl
└── tb
    └── DFlipFlop_tb.vhdl

in your CMakeLists.txt file might have something like

[source, cmake]
file(GLOB hdlfiles hdl/*)
file(GLOB tbfiles tb/*)

we might want to add message function calls to check to make sure that cmake is finding the files as expected.  We end up with the cmake file

[source,cmake]
cmake_minimum_required(VERSION 3.3)
project(globfilelists)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)
file(GLOB hdlfiles hdl/*.vhdl)
file(GLOB tbfiles tb/*.vhdl)
message(STATUS "hdlfiles ${hdlfiles}")
message(STATUS "tbfiles ${tbfiles}")

WARNING: glob only works on files that exist when cmake is run.  Use a different approach for absolute paths to generated files.

This prints a semicolon separated lists of absolute paths to the files in hdl and tb.

==== get_filename_component

An absolute path can be gotten from a relative path using the function get_filename_component with the REALPATH mode like so

[source, cmake]
get_filename_component(hdlfile hdl/DFlipFlop.vhdl REALPATH)
message(STATUS "hdlfile ${hdlfile}")

We can use a foreach loop over a list to call this function on every filename in the list.

[source, cmake]
set(filenames
  hdl/DFlipFlop.vhdl
  hdl/GenericDFlipFlop.vhdl
  )
foreach(filename ${filenames})
  get_filename_component(hdlfile ${filename} REALPATH)
  message(STATUS "file ${hdlfile}")
endforeach()


==== read_filelist

More experienced build system users tend to recommend having an explicit list of files, rather than globing for the files in a directory.

This can be accomplished by explicitly listing the files in the cmakelists file, like we did in the get_filename_component example.

However, putting the list of source in a separate file than your CMakeLists.txt file makes generating this list easier, enables you to reuse the file list across different build systems, and reduces clutter.

The cmake_utils repo provides a function a function called "read_filelist" to specify filepaths.  To use this function, create a file that has a relative file paths of the files you want in your list.

for example, in my hdl folder, I might have a listfile.txt file that says

[source, verbatim]
DFlipFlop.v
ShiftReg.v

Then, in your CMakeLists.txt file, call the read_filelist function.  The same example as before might look something like this.

[source,cmake]
----
cmake_minimum_required(VERSION 3.3)
project(filelists)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)

include(viv-prj-gen/cmake_utils/file_functions.cmake)

get_filename_component(hdllistfile hdl/filelist.txt REALPATH)
get_filename_componnet(tblistfile tb/filelist.txt REALPATH)

read_filelist(hdlfiles ${hdllistfile})

message(STATUS "hdlfiles ${hdlfiles}")
----

on a tree that that looks like this

[source, verbatim]
.
├── build
├── CMakeLists.txt
├── hdl
│   ├── DFlipFlop.v
│   ├── filelist.txt
│   └── ShiftReg.v
└── viv-prj-gen
    ├── cmake_utils/file_functions.cmake
    └── vivgen_functions.cmake


== Vivado Project Generation

A Vivado project is useful for interacting with the code using Vivado's gui.  This is great for nonautomated simulations.

Let's generate one.  We are going to use the add_vivado_devel_project function.  Documentation for functions in vivgen_functions.cmake is in vivgen_functions.adoc .

The first thing we need to do is include our .cmake files and get paths to our hdl files.  Lets say our file system, looks like this.  I added some data files that the testbenches might read from.

[source, verbatim]
.
├── build
├── CMakeLists.txt
├── hdl
│   ├── DFlipFlop.v
│   ├── filelist.txt
│   └── ShiftReg.v
├── tb
│   ├── filelist.txt
│   ├── tb_DFlipFlop.sv
│   └── tb_ShiftReg.sv
├── testdata
│   ├── DFlipFlop
│   │   ├── DFlipFlop_test0.dat
│   │   └── DFlipFlop_test1.dat
│   ├── filelist.txt
│   └── ShiftReg
│       ├── ShiftReg_test0.dat
│       └── ShiftReg_test1.dat
└── viv-prj-gen
    |
    .
    .
    .

The testdata/filelist.txt would look like this

[source, verbatim]
DFlipFlop/DFlipFlop_test0.dat
DFlipFlop/DFlipFlop_test1.dat
ShiftReg/ShiftReg_test0.dat
ShiftReg/ShiftReg_test1.dat

We need to include our two cmake function files and find our source code.

[source, cmake]
----
include(viv-prj-gen/vivgen_functions.cmake)
include(viv-prj-gen/utils_functions.cmake)

get_filename_component(hdllistfile hdl/filelist.txt REALPATH)
get_filename_component(tblistfile tb/filelist.txt REALPATH)
get_filename_component(datalistfile testdata/filelist.txt REALPATH)

read_filelist(hdlfiles ${hdllistfile})
read_filelist(tbfiles ${tblistfile})
read_filelist(datafiles ${datalistfile})
----

The vivgen_func requires us to give it a name for its project, a partname for the chip the project is for, and some kind of source files.  Let's put our design on a zynq chip and call our project "test.

[source, cmake]
----
set(mypartname "XC7Z020-1CLG484")

add_vivado_devel_project(
  PRJNAME test
  PARTNAME ${mypartname}
  VERILOGSYNTHFILES ${hdlfiles}
  SVSIMFILES ${tbfiles} ${hdlfiles}
  DATAFILES ${datafiles}
  )
----

That's all we need.  Our file will now look like this

[source, cmake]
----
cmake_minimum_required(VERSION 3.3)
project(prjgen)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)

include(viv-prj-gen/vivgen_functions.cmake)
include(viv-prj-gen/utils_functions.cmake)

get_filename_component(hdllistfile hdl/filelist.txt REALPATH)
get_filename_component(tblistfile tb/filelist.txt REALPATH)
get_filename_component(datalistfile testdata/filelist.txt REALPATH)

read_filelist(hdlfiles ${hdllistfile})
read_filelist(tbfiles ${tblistfile})
read_filelist(datafiles ${datalistfile})

set(mypartname "XC7Z020-1CLG484")

add_vivado_devel_project(
  PRJNAME test
  PARTNAME ${mypartname}
  VERILOGSYNTHFILES ${hdlfiles}
  SVSIMFILES ${tbfiles} ${hdlfiles}
  DATAFILES ${datafiles}
  )

----

If we navigate into the build directory, run "cmake ..", then "make help", it will print something like

[source, verbatim]
The following are some of the valid targets for this Makefile:
... all (the default if no target is provided)
... clean
... depend
... rebuild_cache
... edit_cache
... test_genvivprj

The last option is the target that our function added.  source your vivado distributions settings64.sh or settings64.bat to tell your cmdline where your vivado is.  Then run "make test_genvivprj" from your build directory.  Vivado will run and generate the project!  

== nonproject flow bitfile generation

To generate a bit file, we use the add_vivado_nonprj_bitfile function in vivgen_functions.cmake (documented in vivgen_functions.adoc).

To generate a bit file, we need a constraint file to tell vivado what logical ports go to what physical pins.

Let's say we've got a project directory structure that looks like this.

[source, verbatim]
.
├── CMakeLists.txt
├── constraints
│   └── unscopedlate
│       ├── filelist.txt
│       └── system.xdc
├── hdl
│   ├── DemoTop.vhdl
│   ├── DFlipFlop.vhdl
│   └── filelist.txt
├── tb
│   ├── filelist.txt
│   └── tb_DFlipFlop.vhdl
└── viv-prj-gen
    |
    .
    .
    .

We still might want to make edits using the vivado gui, so, we'll create a vivado project like the last in the last section.

This time, we won't have any data files, but we'll add the constraint file.

[source, cmake]
----
cmake_minimum_required(VERSION 3.3)
project(nonprj)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)

include(viv-prj-gen/vivgen_functions.cmake)
include(viv-prj-gen/utils_functions.cmake)

get_filename_component(hdllistfile hdl/filelist.txt REALPATH)
get_filename_component(tblistfile tb/filelist.txt REALPATH)
get_filename_component(lateconstrlistfile constraints/unscopedlate/filelist.txt REALPATH)

read_filelist(hdlfiles ${hdllistfile})
read_filelist(tbfiles ${tblistfile})
read_filelist(lateconstrfiles ${lateconstrlistfile})

set(mypartname "XC7Z020-1CLG484")

add_vivado_devel_project(
  PRJNAME test
  PARTNAME ${mypartname}
  VHDLSYNTHFILES ${hdlfiles}
  VHDLSIMFILES ${tbfiles} ${hdlfiles}
  UNSCOPEDLATEXDC ${lateconstrfiles}
 )
----

The function call to define a recipe for a bit file is fairly similar.  The bit file doesn't need the testbench.  It needs to know what the name of the top module is, and we need to get from it the location of the output bitfile.

[source, cmake]
set(nonprjname "nonprjdemo")
add_vivado_nonprj_bitfile(
  PRJNAME ${nonprjname}
  TOPNAME DemoTop
  PARTNAME ${partname}
  VHDLFILES ${hdlfiles}
  UNSCOPEDLATEXDC ${lateconstrfiles}
  BITFILE_OUTPUT ${nonprjname}_bitfile
  )

This creates a recipe for a bitfile, and stores the location it would put the bitfile in the variable nonprjdem_bitfile.

To get this recipe to run, we need to set up a target that depends on that file.  cmake has a function for this called "add_custom_target".

[source, cmake]
add_custom_target(nonprj
  DEPENDS ${${nonprjname}_bitfile}
  )

Now, make help will list nonprj as an option, and running make nonprj will generate our bit file.  The entire cmake file is listed below.

[source,cmake]
----
cmake_minimum_required(VERSION 3.3)
project(prjgen)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)

include(viv-prj-gen/vivgen_functions.cmake)
include(viv-prj-gen/cmake_utils/file_functions.cmake)

get_filename_component(hdllistfile hdl/filelist.txt REALPATH)
get_filename_component(GLOB tblistfile tb/filelist.txt REALPATH)
get_filename_component(GLOB lateconstrlistfile constraints/unscopedlate/filelist.txt REALPATH)

read_filelist(hdlfiles ${hdllistfile})
read_filelist(tbfiles ${tblistfile})
read_filelist(lateconstrfiles ${lateconstrlistfile})

set(mypartname "XC7Z020-1CLG484")

add_vivado_devel_project(
  PRJNAME test
  PARTNAME ${mypartname}
  VHDLSYNTHFILES ${hdlfiles}
  VHDLSIMFILES ${tbfiles} ${hdlfiles}
  UNSCOPEDLATEXDC ${lateconstrfiles}
  )

set(nonprjname "nonprjdemo")

add_vivado_nonprj_bitfile(
  PRJNAME ${nonprjname}
  TOPNAME DemoTop
  PARTNAME ${partname}
  VHDLFILES ${hdlfiles}
  UNSCOPEDLATEXDC ${lateconstrfiles}
  BITFILE_OUTPUT ${nonprjname}_bitfile
  )

add_custom_target(nonprj
  DEPENDS ${${nonprjname}_bitfile}
  )
----

== hardware description file generation
== Generating a XACT IP wrapper
== Generating a xci file

[appendix]
== cmake Basics Continued
=== File paths entry Alternative
==== add_dependency_tree_file get_list_from_dependency_tree

If you want to build lots of outputs based on your input set, sometimes it is helpful to represent your sources by what other sources they depend on.

cmake_utils provides 2 functions to do this.

add_dependency_tree_file reads a file and saves the source dependencies that are listed in it.  get_list_from_dependency_tree reads those source dependencies and generates a list from it.

If we had a file tree that looked like this

[source, verbatim]
.
├── build
├── CMakeLists.txt
├── hdl
│   ├── DFlipFlop.v
│   └── ShiftReg.v
├── file_deplist.txt
├── tb
│   ├── tb_DFlipFlop.sv
│   └── tb_ShiftReg.sv
└── viv-prj-gen
    ├── demos
    ├── docs
    ├── LICENSE
    ├── README.md
    ├── tcl
    ├── tests
    ├── cmake_utils/file_functions.cmake
    └── vivgen_functions.cmake

Let's say

* ShiftRegister.v  instantiate DFlipFlop.v 
* DFlipFlop_tb.sv instantiates DFlipFlop.v
* ShiftRegister_tb.sv instantiates ShiftRegister.v 

This could be represented in file_deplist.txt like this

[source, verbatim]
hdl/ShiftRegister.v <= hdl/DFlipFlop.v
tb/DFlipFlop_tb.sv <= hdl/DFlipFlop.v
tb/ShiftRegister_tb.sv <= hdl/ShiftRegister.v

We don't need to say that ShiftRegister_tb.sv depends on DFlipFlop.v, because it only depends on it indirectly through ShiftRegister.v .  get_list_from_dependency_tree will recursively handle that for us.

[source, cmake]
----
cmake_minimum_required(VERSION 3.3)
project(filelists)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)

include(viv-prj-gen/cmake_utils/file_functions.cmake)

get_filename_component(hdldepfile file_deplist.txt REALPATH)
add_dependency_tree_file(hdlheadfiles ${hdldepfile})
get_filename_component(shiftregister_tb_file tb/ShiftRegister_tb.sv REALPATH)

get_list_from_dependency_tree(ShiftRegister_tb_list  ${shiftregister_tb_file})

message(STATUS "shift register tb list: ${ShiftRegister_tb_list}")
----
